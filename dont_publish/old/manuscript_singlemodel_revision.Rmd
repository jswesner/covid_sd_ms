---
title: "Forecasting hospitalizations due to COVID-19 in South Dakota"
bibliography: references.bib
output:
  bookdown::pdf_document2: 
    fig_caption: yes
    keep_tex: yes
    toc: false
  bookdown::html_document2: 
    toc: false
    df_print: paged
---
# Authors
*Jeff Wesner*^1^, *Dan Van Peursem*^2^, *Jose Flores*^2,3^, *Yuhlong Lio*^2^, *Chelsea Wesner*^3

University of South Dakota

^1^Department of Biology, ^2^Department of Mathematical Sciences, ^3^Department of Computer Science, ^3Master of Public Health Program

<Jeff.Wesner@usd.edu>

# Abstract
Anticipating the number of hospital beds needed for patients with COVID-19 remains a challenge. Early efforts to predict hospital bed needs focused on deriving predictions from SIR models, largely at the level of countries, provinces, or states. In the United States, these models rely on data reported by state health agencies. However, predictive disease and hospitalization dynamics at the state level is complicated by geographic variation in disease parameters. In addition it is difficult to make forecasts early in a pandemic due to minimal data. However, Bayesian approaches that allow models to be specified with informed prior information from areas that have already completed a disease curve can serve as prior estimates for areas that are beginning their curve. Here, we used a Bayesian non-linear regression (Weibull equation) to forecast cumulative and active COVID-19 hospitalizations for South Dakota, USA. As expected, early forecasts were dominated by prior information, which we derived from New York City. Importantly, hospitalization trends also differed within South Dakota due to early peaks in urban Minnehaha County, followed by later peaks in other rural areas of the state. Combining these trends in an interaction model led to altered forecasts with relevant policy implications. 

# Introduction
The novel coronavirus (SARS-CoV-2) was first detected in December 2019 in Wuhan, China and has since spread globally. The disease caused by SARS-CoV-2 (COVID-19) can lead to hospitalization or death in all age groups, but particularly in older age groups with comorbidities such as hypertension, obesity, and diabetes [@richardson_presenting_2020]. For example,in France @salje_estimating_2020 estimated that 3.6% of infected people become hospitalized, but that rate varies from a low of 0.001% to 10.1% for individuals that are <20 years old versus those >80 years old, respectively. A central challenge for hospitals is predicting how many hospitalizations will occur due to COVID-19, and whether hospital capacities will be exceeded. 
  Predicting hospitalization needs due to COVID-19 may be particularly challenging in rural areas. For example, relative to urban areas, rural communities in the U.S. have reduced access to health care [@research_national_2016] and increased mortality from chronic diseases [@moy_leading_2017], both of which are key risk factors for COVID-19. South Dakota is among the most rural states in the U.S. with a 2017 population estimate of 869,666 [@bureau_acs_2017]. Of South Dakota’s 66 counties, 52% are frontier (with ≤15.5 persons per square kilometer) and 32% encompass or are comprised of reservation lands representing nine federally recognized tribes. Communiites in rural areas also tend to have an older poplution. For example, among 56 U.S. counties with the largest proportion of people ages ≥85, all but 2 counties are rural and a county in South Dakota ranks first [@henning-smith_characteristics_2020]. South Dakota’s public health infrastructure is limited with a centralized state department of health and a single public nurse in each county to support the delivery of public health interventions and resources. Nearly 80% of nonprofit hospitals in South Dakota are critical access hospitals with 25 or fewer acute inpatient beds [@noauthor_doh_nodate], and acess to medical facilities with an intensive care unit (ICU) and ventilators is limited in rural areas [@casey_availability_2018].
  To our knowledge, there are no published studies that model hospitalizations due to COVID-19 in rural and low resource settings. Developing new ways to model infectious disease outbreaks in jurisdictions with limited public health and health care infrastructure is critical to preventing and reducing mortality and morbidity in communities that are at high risk COVID-19. Here, we modeled cumulative hospitalizations in and urban and rural populations within South Dakota using a Bayesian non-linear Weibull function. Because early predictions in a disease outbreak are critical for planning, but also are data limited, we used informed priors from New York City, which began its hospitalization curve before South Dakota. While New York City is not a rural area, the use of informed prior distributions allowed our model to make reasonable, though highly uncertain, forecasts of hospitalizations in a rural setting.
  
# Methods

**Data Retrieval**

We obtained data on cumulative hospitalizations and active hospitalizations (number hospitalized on a given day) from the data dashboard for the South Dakota Department of Health (SD DOH) - https://doh.sd.gov/news/Coronavirus.aspx#SD. Data for cumulative hospitalizations began on 2020-03-08 and were entered by hand into a .csv each day (SD DOH only reports totals for the current day, not a timeline). Data for active hospitalizations were not released until 2020-04-20, when 56 people were actively hospitalized. Beginning on that date, we also updated our .csv with active hospitalizations each day.
  When data collection began, most cases and hospitalizations were located in a single county in South Dakota, Minnehaha  County. Therefore, during data collection, we noted hospitalizations in Minnehaha County versus the rest of South Dakota to capture any potential divergent trends. For these two groups, data are only available for cumulative hospitalizations, not for active hospitalizations.

**Models**

We estimated the cumulative hospitalizations using a Bayesian non-linear sigmoid model in which hospitalizations were modeled as a function of time using the Weibull function [@yang_potential_1978; @narushin_sigmoid_2003]. The Weibull function is derived from the Weibull cumulative distribution (@weibull_statistical_1951) and has been used widely in biology to model growth curves [pielou_usefulness_1981]. We chose the Weibull function because it is more flexible than the logistic function and is asymmetric around the inflection point [@yang_potential_1978;@kumar_epidemiological_nodate]. We fit the Weibull function to two sets of data that describe 1) the cumulative hospitalizations for the state of South Dakota and 2) the cumulative hospitalizations for subgroups of Minnehaha County and the rest of South Dakota. Becuase the data were counts with positive outcomes, we used a Poisson likelihood with a log-link. 

*Model 1*

$$y_i \sim Poisson(\lambda_i)$$ 
$$log\lambda_i = \alpha_i(1 - exp(-\frac{x_i}{\beta_i})^{\gamma_i})$$ 

$$\alpha \sim Gamma(64,8)$$
$$\beta \sim Gamma(2.9, 0.18)$$ 
$$\gamma \sim Gamma(5.8,4.8)$$

where *y_i* is the cumulative number of people hospitalized in South Dakota on the *ith* date, $\alpha$ is the asymptote, $\beta$ is the inflection point, and $\gamma$ is the slope at the inflection point. Gamma priors were used because each parameter must be positive and continuous.
  Informative prior distributions were derived from the cumulative hospitalization curve in New York City (NYC Department of Health, https://www1.nyc.gov/site/doh/covid/covid-19-data.page). We derived the priors from New York City because NYC had nearly completed its hospitalization curve when South Dakota's was still beginning and because the data were available as a timeline (many states either have not reported temporal hospitalization data or have not made the data easily extractable).
  To derive prior distributions for South Dakota, we first fit the aforementioned model to NYC's hospitalization curve. Before fitting the model, we multiplied NYC hospitalizations by 0.10 to put them on the scale of South Dakota's population (which is ~10% of NYC's population). We then fit the model to these adjusted hospitalizations using prior values of *Gamma*(1.2, 0.1) for $\alpha$, *Gamma*(0.25, 0.005) for $\beta$, and *Gamma*(1.4, 0.3) for $\gamma$. Those reflect prior distributions with wide standard deviations that would represent a potential overload of South Dakota's ~ 2000 hospital beds: 10,000 +/- 5000 (mean +/- sd) for $\alpha$, 50 +/- 100 for $\beta$, and 100 +/- 50 for $\gamma$. 

*Model 2*

Within South Dakota, Minnehaha County is the most densely populated area of the state, containing the largest city in South Dakota - Sioux Falls, SD. Daily tracking revealed a clear separation between trends (in both cases and hospitalizations) in Minnehaha County compared to trends outside of Minnehaha County. To capture these trends, we fit the same model as before, but included an interaction with two levels (Minnehaha County or Outside Minnehaha County) for each of the three parameters. 

$$y_i \sim Poisson(\lambda_i)$$
$$log\lambda_i = \alpha_j(1 - exp(-\frac{x_i}{\beta_j})^{\gamma_j})$$ 
$$\alpha_j = \alpha_{minn} + \alpha_{rest}r_i$$
$$\beta_j = \beta_{minn} + \beta_{rest}r_i$$
$$\gamma_j = \gamma_{minn} + \gamma_{rest}r_i$$
$$\alpha_{minn} \sim Gamma(49,7)$$
$$\alpha_{rest} \sim Normal(0,1)$$
$$\beta_{minn} \sim Gamma(2.9, 0.18)$$
$$\beta_{rest} \sim Normal(0, 5)$$
$$\gamma_{minn} \sim Gamma(5.8, 4.8)$$
$$\gamma_{rest} \sim Normal(0,0.5)$$

where *y_i* is the cumulative number of people hospitalized in each *i* date (*x_i*),  $\alpha_j, \beta_j,$ and $\gamma_j$ are the parameters for each *j* group (Minnehaha County or the Rest of South Dakota), $X_{minn}$ are the priors for each X parameter ($\alpha$, $\beta$, $\gamma$), $X_{rest}$ are the priors for the difference in parameter values between Minnehaha and the Rest of South Dakota, and $r_i$ is an indicator variable that is 0 if the data are in Minnehaha County and 1 otherwise.
  As before, prior values were chosen from a combination of prior information from NYC and from prior predictive simulation [@gabry_visualization_2019]. To do this, we simulated 300 cumulative hospitalization curves with mean values for each parameter derived from the fit of the NYC model. Because NYC has both a higher absolute population size and a higher population density (by 10-fold) than South Dakota, we adjusted prior means and standard deviations so that the prior predictive distributions estimated hospitalizations to have a maximum that is slighly below the maximum of NYC, but with standard deviations that still include positive prior probability for some extreme prediction (e.g., 50,000 cumulative hospitalizations). Figure 1 shows the prior predictions for both models.


*Hamiltonian Monte Carlo*

Each model aforementioned was specified in R (version 3.6.3; R Core Team 2020) using the *brms* package [@burkner_brms_nodate]. Posterior sampling was performed using Hamiltonian Monte Carlo in *rstan* (version 2.19.2, [@carpenter_stan_2017]). We fit four chains, each with 2000 iterations, discarding the first 1000 iterations of each chain as warm-up. Warm-up samples are similar to burn-in sampling, but are used in this case as an optimizer for the HMC algorithm. Chains were checked for convergence using trace plots to assure overlap (*Supplementary Information*), and by ensuring that the Gelman-Rubin convergence diagnostic (*r-hat*) was < 1.1 [@gelman_inference_1992].

*Parameter change over time*

To determine how parameter values changed over time as data are added, we fit the model every twenty days and plotted the posterior distributions of parameter values against time. 

*Posterior prediction*
To forecast cumulative hospitalizations, we used the posterior predictive distributions from each model by first solving for the fitted values across each iteration of the posterior:

$$yfit_i^{(k)} = exp(\alpha_i^{(k)}(1 - exp(-\frac{x_i}{\beta_i^{(k)}})^{\gamma_i^{(k)}}))$$
where *k* is the $k^{th}$ iteration from the posterior distribution and *i* is the $i^{th}$ date. Posterior predicted values were estimated by drawing each $ypred_i^{(k)}$ from the Poisson distribution:

$$ypred_i^{(k)} = Poisson(yfit_i^{(k)})$$ 
We then summarized the mean, median, standard deviation and credible intervals (50 and 95%) across the posterior distribution of fitted and predicted values. For visualization, we plotted fitted values within the range of the data and predicted values beyond the range of the data. 

*Estimating Active Hospitalizations*

To estimate active hospitalizations from the cumulative hospitalization curve, we first derived daily incidence $\phi$ for each iteration of $yfit_{ki}$ in which 

$$\phi_{ki} = yfit_i^{(k)} - yfit_{i-1}^{(k)}$$

We then summed incidence over the previous 5, 10, 12, or 15 days to estimate variable lengths of hospital stays:
$$\omega_i^{(k)} = \phi_i^{(k)} + \phi_{i-1}^{(k)} + \phi_{i-2}^{(k)}...\phi_{i-n}^{(k)}$$

where $\omega_i^{(k)}$ is the number of people actively hospitalized on the $i^th$ day for the $k^th$ iteration, $\phi_i^{(k)}$ is the incidence on the $i^th$ day for the $k^th$ iteration and *n* is 5, 10, 12, or 15 (NEED CITATION). 

We then plotted these predictions against active hospitalizations reported by the South Dakota Department of Health. For the group levels (*Model 2*), we performed the same calculations as above, but for each group. In addition, we also estimated the state-level hospitalizations from *Model 2* by summing the predictions from each group. This allowed us to compare predictions when only state-level data were available versus predictions with data available for different areas of the state.  

```{r Load packages, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
library(tidyverse)
library(scales)
library(ggridges)
library(here)
library(RcppRoll)
library(janitor)
library(viridis)
library(deSolve)
library(scales)
library(lubridate)
library(viridis)
library(readr)
library(readxl)
library(ggrepel)
library(cowplot)
library(viridis)
library(brms)
library(kableExtra)
library(ggpubr)
library(citr)
library(rticles)
```

```{r Load hospitalization data, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
cum_hosp <- read_csv("data/cum_hosp.csv", na = c("", ".")) %>% 
  mutate(date = mdy(date_hosp),
         date_numeric  = as.numeric(date),
         date_original = date_numeric - min(date_numeric),
         group_short = str_sub(group,1,1)) %>% filter(cum_hosp > 0) %>% 
  mutate(date_correct = case_when(grepl("innehah", group) ~ 12, TRUE ~ 0),
         date_num = date_original - date_correct)

cum_hosp_state <- cum_hosp %>% ungroup() %>% group_by(date, date_original) %>% summarize(cum_hosp = sum(cum_hosp)) %>% 
  mutate(date_num = date_original)

nyc_hosp <- read_csv(here::here("data/nyc_hosp.csv")) %>% clean_names() %>% 
  mutate(date = mdy(date_of_interest),
         date_num = as.numeric(date) - min(as.numeric(date)),
         cum_hosp = cumsum(hospitalizations),
         nyc_pop = 8300000,
         prop_hosp = cum_hosp/nyc_pop,
         model = "Model 1",
         group = "All of South Dakota",
         pop_correct = 884000/8300000,
         cum_hosp_corrected = as.integer(cum_hosp*pop_correct),
         model = "NYC")
```

```{r Plot NYC data, echo=FALSE, fig.cap="Left: Model of New York City's hospitalization curve. Data are divided by 10 to reflect the relative population sizes in South Dakota versus New York city. Three-hundred simulations of cumulative hospitalizations from the prior predictive distribution of each model. Priors for Model 1 were derived from the fit of NYC's hospitalization curve. Priors for Model 2 were similar to those of Model 1, but had a reduced prediction of cumulative hospitalizations to account for the smaller populations of each group (Minnehaha County vs Outside Minnehaha County) relative to the whole state population.", fig.height=4, fig.width=12, message=FALSE, warning=FALSE, paged.print=FALSE}
#data from https://www1.nyc.gov/site/doh/covid/covid-19-data.page

# gamma_parms <- function(mean, sd) {
#   out <- tibble(shape = mean^2/sd^2,
#                 rate = mean/sd^2,
#                 scale = 1/(mean/sd^2))
#   return(out)
#   return(plot)
# }
# 
# gamma_parms(mean = 8, sd = 1)
# gamma_parms(mean = 17, sd = 10)
# gamma_parms(mean = 1.2, sd = .5)
# # 
# tibble(ult = rgamma(300, 25, 3.3),
#                 omega = rgamma(300, 4, 0.2),
#                 theta = rgamma(300, 4, 2)
# nyc_model <- brm(bf(cum_hosp_corrected ~ ult*(1 - exp(-(date_num/omega)^theta)),
#                   ult ~ 1 , omega ~ 1 , theta ~ 1 ,
#                   nl = TRUE ),
#                data = nyc_hosp,
#                family = poisson(link = "log"),
#                prior = c(
#                  prior(gamma(1.2, 0.1), nlpar = "ult"), #asymptote - based on proportion total hosp in NY
#                  prior(gamma(0.25, 0.005), nlpar = "omega"), #time (days since start) of inflection
#                  prior(gamma(1.4, 0.3), nlpar = "theta")), # slope at inflection. Gamma to ensure it is positive (has to be since data are cumulative) assumes slope of exp(2) with sd of 0.5
#                iter = 1000, chains = 1)
# saveRDS(nyc_model, file = "outputs/nyc_model.rds")

nyc_model <- readRDS(file = "outputs/nyc_model.rds")
nyc_pred <- predict(nyc_model) %>% as_tibble() %>% clean_names() %>% mutate(date_num = nyc_hosp$date_num,
                                                                            model = "NYC")

nyc_plot <- nyc_pred %>% 
  ggplot(aes(x = date_num, y = estimate)) +
  geom_line() +
  geom_ribbon(aes(ymin = q2_5, ymax = q97_5), alpha = 0.5) +
  geom_point(data = nyc_hosp, aes(y = cum_hosp_corrected), size = 0.5) +
  scale_y_log10() +
  coord_cartesian(ylim = c(1, 100000)) +
  theme_classic() +
  facet_grid(~model) +
  labs(subtitle = "NYC data (scaled to SD's population)",
       y = "NYC Cumulative Hospitalizations*0.1") +
  NULL

state_priors <- tibble(ult = rgamma(300, 64, 8),
                omega = rgamma(300, 2.9, .17),
                theta = rgamma(300, 5.8, 4.8),
                iter = 1:300) %>% 
  expand_grid(date_num = seq(1, 150, by = 1)) %>% 
  mutate(fit = exp(ult*(1 - exp(-(date_num/omega)^theta))),
         pred = rpois(nrow(.), fit),
         group = "All of South Dakota",
         model = "Model 1")


group_priors <- tibble(ult = rgamma(300, 64, 8),
                       omega = rgamma(300, 2.9, .17),
                       theta = rgamma(300, 5.8, 4.8),
                       ult_r = rnorm(300, 0, 1),
                       omega_r = rnorm(300, 0, 5),
                       theta_r = rnorm(300, 0, 0.5),
                       iter = 1:300) %>% 
  expand_grid(date_num = 1:150) %>% 
  mutate(y_minn = exp(ult*(1 - exp(-(date_num/omega)^theta))),
         y_rest = exp((ult + ult_r)*(1 - exp(-(date_num/(omega + omega_r))^(theta + theta_r)))),
         y_minn_pred = rpois(nrow(.), y_minn),
         y_rest_pred = rpois(nrow(.), y_rest)) %>% 
  gather(key, pred, c(y_minn_pred:y_rest_pred)) %>% 
  mutate(group = case_when(grepl("minn", key) ~ "Minnehaha County",
                           TRUE ~ "Outside of Minnehaha"),
         model = "Model 2")


plot_priors <- state_priors %>% select(pred, iter, group, date_num,model) %>% 
  bind_rows(group_priors %>% select(pred, group, iter, date_num, model))


pop_correct = 884000/8400000

prior_predictive <- plot_priors %>% 
  ggplot(aes(x = date_num, y = pred, color = group)) +
  geom_line(aes(group = interaction(group,iter)), alpha = 0.2) +
  # geom_point(data = nyc_hosp, aes(y = cum_hosp*pop_correct), color = "black", shape = 21) +
  scale_y_log10() +
  facet_wrap(~ model) +
  labs(y = expression(paste("SD Cumulative Hospitalizations")),
       x = "Days since first hospitalization",
       subtitle = "Prior predictive simulations") +
  theme_classic() + 
  coord_cartesian(ylim = c(1, 100000)) +
  scale_color_brewer(type = "qual", palette = 8) +
  # scale_color_manual(values = c("black", "red", "blue")) +
  guides(color = guide_legend(override.aes = list(alpha = 1))) +
  theme(legend.title = element_blank()) +
  NULL




prior_plots <- plot_grid(nyc_plot, prior_predictive, ncol = 2, rel_widths = c(0.33, 0.67), align = "h")

prior_plots
```

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
nyc_fixef <- fixef(nyc_model)
set.seed(202)

nycpostprior <- tibble(param = c("alpha", "beta", "gamma", "alpha_rest", "beta_rest", "gamma_rest"),
       mean_nyc_posterior = c(nyc_fixef[1], nyc_fixef[2], nyc_fixef[3], NA, NA, NA),
       sd_nyc_posterior = c(nyc_fixef[4], nyc_fixef[5], nyc_fixef[6], NA, NA, NA),
       mean_m1_prior = c(mean(rgamma(1000, 64, 8)), mean(rgamma(1000, 2.9, 0.17)), mean(rgamma(1000, 5.8, 4.8)), NA, NA, NA),
       sd_m1_prior = c(sd(rgamma(1000, 64, 8)), sd(rgamma(1000, 2.9, 0.17)), sd(rgamma(1000, 5.8, 4.8)), NA, NA, NA),
       mean_m2_prior = c(mean(rgamma(1000, 49,7)), mean(rgamma(1000, 2.9, 0.17)), mean(rgamma(1000, 5.8, 4.8)),
                         0, 0, 0),
       sd_m2_prior = c(sd(rgamma(1000, 49,7)), sd(rgamma(1000, 2.9, 0.17)), sd(rgamma(1000, 5.8, 4.8)),
                       1, 5, 0.5))
nycpostprior_table <- nycpostprior %>% gather(key, value, -param) %>% 
  separate(key, c("measure", "model", "post_prior")) %>% 
  pivot_wider(names_from = measure, values_from = value) %>% 
  mutate(shape = mean^2/sd^2,
         rate = mean/sd^2) %>% 
  mutate_if(is.numeric,round, 2) %>% 
  arrange(desc(param)) %>% 
  drop_na() %>% 
  mutate(shape = na_if(shape, 0),
         rate = na_if(rate, 0))

kable(nycpostprior_table, "latex", caption = "Posterior distributions from the New York City model and the prior distributions for the South Dakota models.", booktabs = T) %>%
kable_styling(latex_options = c("striped", "hold_position"))
```

```{r Fit state model, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
set.seed(202)

# fit_weib_state <- brm(bf(cum_hosp ~ ult*(1 - exp(-(date_num/omega)^theta)),
#    ult ~ 1 , omega ~ 1 , theta ~ 1 ,
#    nl = TRUE ),
# data = cum_hosp_state,
# family = poisson(link = "log"),
# prior = c(
#   prior(gamma(64, 8), nlpar = "ult"), #asymptote - based on proportion total hosp in NY
#   prior(gamma(2.9, 0.17), nlpar = "omega"), #time (days since start) of inflection
#   prior(gamma(5.8, 4.8), nlpar = "theta")), # slope at inflection. Gamma to ensure it is positive (has to be since data are cumulative) assumes slope of exp(2) with sd of 0.5
# iter = 2000, chains = 4, sample_prior = "yes")
# saveRDS(fit_weib_state, file = "outputs/fit_weib_state.rds")

fit_weib_state <- update(readRDS(here::here("outputs/fit_weib_state.rds")), newdata = cum_hosp_state)
saveRDS(fit_weib_state, file = here::here(paste0("outputs/fit_weib_state_", Sys.Date(), ".rds")))
```

```{r Fit group model, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
# get_prior(bf(cum_hosp ~ (ult*date_num^omega)/(theta^omega + date_num^omega),
#                         ult ~ 1 + group, omega ~ 1 + group, theta ~ 1 + group,
#                         nl = TRUE ),
#                      data = cum_hosp,
#                      family = poisson(link = "log"))
# 

# fit_weib_group_f <-  brm(bf(cum_hosp ~ ult*(1 - exp(-(date_num/omega)^theta)),
#                         ult ~ 1 + group, omega ~ 1 + group, theta ~ 1 + group,
#                         nl = TRUE ),
#                      data = cum_hosp,
#                      family = poisson(link = "log"),
#                      prior = c(
#                        prior(gamma(49,7), nlpar = "ult", lb = 0), #asymptote - based on proportion total hosp in NY
#                        prior(gamma(2.9, 0.17), nlpar = "omega", lb = 0), #time (days since start) of inflection
#                        prior(gamma(5.8, 4.8), nlpar = "theta", lb = 0),
#                        prior(normal(0,1), coef = "groupRestofSouthDakota", nlpar = "theta"),
#                        prior(normal(0,5), coef = "groupRestofSouthDakota", nlpar = "omega"),
#                        prior(normal(0,0.5), coef = "groupRestofSouthDakota", nlpar = "ult")),
#                      iter = 2000, chains = 4, sample_prior = T)
# 
# saveRDS(fit_weib_group_f, file = here::here("outputs/fit_weib_group_f.rds"))

fit_weib_group_f <- update(readRDS(here::here("outputs/fit_weib_group_f.rds")), newdata = cum_hosp)

saveRDS(fit_weib_group_f, file = here::here("outputs/fit_weib_group_f.rds"))
#update models
# fit_weib_group <- update(readRDS(here::here("outputs/fit_weib_group.rds")), newdata = cum_hosp)
```

```{r extract posteriors, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

#new dates to condition on
newstatefit <- tibble(date_num = seq(0, max(cum_hosp$date_num, by = 1)))
newstatepred <- tibble(date_num = seq(max(cum_hosp$date_num, 200, by = 1)))

#extract posteriors distributions
#model 1
fit_state <- fitted(fit_weib_state, newdata = newstatefit, probs = c(0.025, 0.25, 0.75, 0.975)) %>% as_tibble() %>% clean_names() %>% 
  mutate(date_num = newstatefit$date_num,
         group = "All of South Dakota",
         prior_post = "Posterior",
         method = "Fitted", 
         model = "Model 1")

pred_state <- predict(fit_weib_state, newdata = newstatepred, probs = c(0.025, 0.25, 0.75, 0.975)) %>% as_tibble() %>% clean_names() %>% 
  mutate(date_num = newstatepred$date_num,
         group = "All of South Dakota",
         prior_post = "Posterior",
         method = "Predicted", 
         model = "Model 1")


#model 2
newminnfit <- tibble(date_num = seq(0, max(cum_hosp$date_num, by = 1)),
                  group = "Minnehaha County")

fit_minn <- fitted(fit_weib_group_f, newdata = newminnfit, probs = c(0.025, 0.25, 0.75, 0.975)) %>% as_tibble() %>% clean_names() %>% 
  mutate(date_num = newminnfit$date_num,
         group = "Minnehaha County",
         prior_post = "Posterior",
         method = "Fitted", 
         model = "Model 2")


newminnpred <- tibble(date_num = seq(max(cum_hosp$date_num), 200, by = 1),
                                    group = "Minnehaha County")

pred_minn <- predict(fit_weib_group_f, newdata = newminnpred, probs = c(0.025, 0.25, 0.75, 0.975)) %>% as_tibble() %>% clean_names() %>% 
  mutate(date_num = newminnpred$date_num,
         group = "Minnehaha County",
         prior_post = "Posterior",
         method = "Predicted", 
         model = "Model 2")


newrestfit <- tibble(date_num = seq(0, max(cum_hosp$date_num, by = 1)),
                  group = "Rest of South Dakota")

fit_rest <- fitted(fit_weib_group_f, newdata = newrestfit, probs = c(0.025, 0.25, 0.75, 0.975)) %>% as_tibble() %>% clean_names() %>% 
  mutate(date_num = newrestfit$date_num,
         group = "Oustide of Minnehaha",
         prior_post = "Posterior",
         method = "Fitted", 
         model = "Model 2")

newrestpred <- tibble(date_num = seq(max(cum_hosp$date_num), 200, by = 1),
                                    group = "Rest of South Dakota")

pred_rest <- predict(fit_weib_group_f, newdata = newrestpred, probs = c(0.025, 0.25, 0.75, 0.975)) %>% as_tibble() %>% clean_names() %>% 
  mutate(date_num = newrestpred$date_num,
         group = "Oustide of Minnehaha",
         prior_post = "Posterior",
         method = "Predicted", 
         model = "Model 2")

posts <- bind_rows(fit_state, pred_state, fit_minn, pred_minn, fit_rest, pred_rest) %>% 
  mutate(date_num = case_when(grepl("County", group) ~ date_num + 12, TRUE ~ date_num)) %>% 
  mutate(date = as_date(18329 + date_num))
```

```{r extract priors, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
#new dates to condition on

#extract prior distributions
#model 1
state_priors <- prior_samples(fit_weib_state) %>% as_tibble() %>% 
  expand_grid(date_num = seq(0, 200, by = 1)) %>% 
  mutate(y_fit_state = exp(b_ult*(1 - exp(-(date_num/b_omega)^b_theta))),
         y_pred_state = rpois(nrow(.), y_fit_state)) %>% 
  gather(key, value, c(y_fit_state:y_pred_state)) %>% 
group_by(date_num, key) %>% 
  summarize(estimate = median(value),
            est_error = sd(value),
            q2_5 = quantile(value, probs = 0.025),
            q25 = quantile(value, probs = 0.25),
            q75 = quantile(value, probs = 0.75),
            q97_5 = quantile(value, probs = 0.975)) %>% 
  mutate(group = "All of South Dakota",
         prior_post = "Prior",
         method = case_when(grepl("fit", key) ~ "Fitted", TRUE ~ "Predicted"),
         model = "Model 1",
         date = as_date(date_num + 18329))

#model 2
group_priors <- prior_samples(fit_weib_group_f) %>% as_tibble() %>% clean_names() %>% 
  expand_grid(date_num = seq(0, 200, by = 1)) %>% 
  mutate(y_fit_minn = exp(b_ult_intercept*(1 - exp(-(date_num/b_omega_intercept)^b_theta_intercept))),
         ult_gr = b_ult_intercept + b_ult_group_restof_south_dakota,
         omega_gr = b_omega_intercept + b_omega_group_restof_south_dakota,
         theta_gr = b_theta_intercept + b_theta_group_restof_south_dakota,
         y_fit_rest = exp(ult_gr*(1 - exp(-(date_num/omega_gr)^theta_gr))),
         y_pred_minn = rpois(nrow(.), y_fit_minn),
         y_pred_rest = rpois(nrow(.), y_fit_rest)) %>% 
  select(-ult_gr, -omega_gr, -theta_gr) %>% 
  gather(key, value, c(y_fit_minn:y_pred_rest)) %>% 
group_by(date_num, key) %>% 
  summarize(estimate = median(value),
            est_error = sd(value),
            q2_5 = quantile(value, probs = 0.025),
            q25 = quantile(value, probs = 0.25),
            q75 = quantile(value, probs = 0.75),
            q97_5 = quantile(value, probs = 0.975)) %>% 
  mutate(group = case_when(grepl("rest", key) ~ "Oustide of Minnehaha", TRUE ~ "Minnehaha County"),
         prior_post = "Prior",
         method = case_when(grepl("fit", key) ~ "Fitted", TRUE ~ "Predicted"),
         model = "Model 2",
         date = as_date(date_num + 18329))


priors <- bind_rows(group_priors, state_priors) %>% filter(method == "Predicted")
```


```{r Plot posteriors and priors, echo=FALSE, fig.cap="Posterior distributions of cumulative hospitalizations in South Dakota. Lines indicate medians and shading indicates the 50 and 90% intervals. Predictions beyond the data represent samples from the posterior predictive distribution. Predictions within the data represent samples from the posterior fitted distribution.", fig.height=6, fig.width=6, message=FALSE, warning=FALSE, paged.print=FALSE}

#combine post and prior preds
post_priors <- bind_rows(posts, priors)


#format raw data to plot
plot_data_group <- cum_hosp %>% 
  select(date, date_num, group, cum_hosp, date_original) %>% 
  mutate(prior_post = case_when(date_num >=0 ~ "Posterior", TRUE ~ "Prior"),
         prior_post = fct_relevel(prior_post, "Prior"),
         model = "Model 2") 

plot_data_state <- cum_hosp_state %>% 
  mutate(prior_post = case_when(date_num >=0 ~ "Posterior", TRUE ~ "Prior"),
         prior_post = fct_relevel(prior_post, "Prior"),
         group = "All of South Dakota",
         model = "Model 1")

plot_data_all <- bind_rows(plot_data_group, plot_data_state)

#modify post predictions so that they are fitted within the data and predictions beyond the data
post_all_plot <- post_priors  %>% 
  filter(prior_post != "Prior") %>% 
  ggplot(aes(x = date, y = estimate)) +
  geom_line(aes(color = group)) +
  geom_ribbon(alpha = 0.2, aes(ymin = q2_5, ymax = q97_5, fill = group)) +
  geom_ribbon(alpha = 0.2, aes(ymin = q25, ymax = q75, fill = group)) + 
  facet_grid(model ~ ., scales = "free") +
  geom_point(data = plot_data_all, aes(x = date, y = cum_hosp, shape = group), size = 0.8) +
  coord_cartesian(ylim = c(1, 800),
                  xlim = c(min(cum_hosp$date), as_date("2020-08-01"))) +
  scale_color_brewer(type = "qual") +
  scale_fill_brewer(type = "qual") +
  theme_bw() +
  # scale_y_log10() +
  labs(y = "Cumulative Hospitalizations",
       x = "") +
  guides(shape = F) +
  theme(legend.title = element_blank(),
        panel.grid = element_blank()) +
  NULL

post_all_plot
```

# Results

At the state level, model 1 predicted a total of 762 hospitalizations (median) in South Dakota (90% CrI: 715 - 816, Table 2). The inflection point was predicted at 28 days after the first hospitalization, suggesting that the peak rate of hospitalizations occurred around April 11, 2020. In contrast, the model with group-level effects separating trends in Minnehaha County clearly showed that hospitalizations trends differed in Minnehaha County verses the rest of South Dakota (Figure 2). In Minnehaha County, the inflection point occurred around day 23 and revealed an asymptote of 316 hospitalizations (90% CrI: 307-324). In the rest of South Dakota, the inflection point occurred ~40 days later (day 62, Figure 2). Similarly, the maximum cumulative hospitalizations in the rest of South Dakota are estimated at a median of ~785, but with large uncertainty (90% CrI: 673-929, Table 2).   


```{r tables, echo=FALSE}
poststate <- posterior_samples(fit_weib_state) %>% tibble() %>% clean_names()
postgroup <- posterior_samples(fit_weib_group_f) %>% tibble() %>% clean_names()


state_table <- poststate %>% tibble() %>% mutate(iter = 1:nrow(.)) %>% 
  mutate(sd_max = exp(b_ult_intercept),
         sd_slope = exp(b_theta_intercept),
         sd_inf = b_omega_intercept) %>%
  select(iter, sd_max, sd_inf, sd_slope) %>% 
  gather(key, value, -iter) %>% 
  group_by(key) %>% 
  summarize(median = round(median(value),1),
            mean = round(mean(value),1),
            sd = round(sd(value),1),
            low90 = round(quantile(value, probs = 0.05),1),
            upper90 = round(quantile(value, probs = 0.95),1)) %>% 
  ungroup() %>% 
  filter(grepl("sd_", key) & !grepl("r_group", key)) %>% 
  mutate(Model = "Model 1",
         Group = case_when(grepl("minn", key) ~ "Minnehaha", TRUE ~ "South Dakota"),
         Parameter = str_sub(key, 4)) %>% 
  select(Model, Group, Parameter, everything(),-key)



group_table <- postgroup %>% tibble() %>% mutate(iter = 1:nrow(.)) %>% 
  mutate(minn_max = exp(b_ult_intercept),
         minn_inf = b_omega_intercept,
         minn_slope = exp(b_theta_intercept),
         rest_max = exp(b_ult_intercept + b_ult_group_restof_south_dakota),
         rest_slope = exp(b_theta_intercept + b_theta_group_restof_south_dakota),
         rest_inf = b_omega_intercept + b_omega_group_restof_south_dakota) %>%
  select(minn_max, minn_inf, minn_slope, rest_max, rest_inf, rest_slope, iter) %>% 
  gather(key, value, -iter) %>% 
  group_by(key) %>% 
  summarize(median = round(median(value),1),
            mean = round(mean(value),1),
            sd = round(sd(value),1),
            low90 = round(quantile(value, probs = 0.05),1),
            upper90 = round(quantile(value, probs = 0.95),1)) %>% 
  ungroup() %>% 
  filter(grepl("minn_", key) | grepl("rest_", key) & !grepl("r_group", key)) %>% 
  mutate(Model = "Model 2",
         Group = case_when(grepl("minn", key) ~ "Minnehaha", TRUE ~ "Outside of Minnehaha"),
         Parameter = str_sub(key, 6)) %>% 
  select(Model, Group, Parameter, everything(),-key)


table_all <- bind_rows(group_table, state_table) %>% mutate(Model = fct_relevel(Model, "Model 2"))

kable(table_all, "latex", caption = "Summary statistics of the asymptote (max), inflection point in days since the first case (inf), and slope at inflection (slope). Values for max and slope are exponentiated to place them on the scale of the response variable (cumulative hospitalizations. Summaries are derived from the posterior distributions of each parameter in the corresponding model.", booktabs = T) %>%
kable_styling(latex_options = c("striped", "hold_position"))

```

As expected the uncertainty in parameter values improved over time as data were added to the model. The largest improvement appeared to occur during the model run on day 60, when all parameter values appeared to stabilize (Figure 3).

```{r echo=FALSE, fig.cap="Change in parameter values over time. Violins represent posterior distributions of parameter values (untransformed) over time as models are fit using data at day 0, 20, 40, 60, 80, 100, and the most recent date.", fig.height=5, fig.width=8, message=FALSE, warning=FALSE, paged.print=FALSE}

posts_methods <- readRDS(file = here("outputs/posts_everything.rds")) %>% as_tibble() %>% 
  mutate(value_trans = case_when(parameter == "slope" ~ value, TRUE ~ exp(value)),
         group = case_when(grepl("rest", key) ~ "Outside of Minnehaha",
                           model == "Model 1" ~ "South Dakota",
                                 TRUE ~ "Minnehaha County"))

posts_methods %>% 
  mutate(day = as.factor(day)) %>% 
  ggplot(aes(x = day, y = value)) +
  # geom_density(trim = T, aes(alpha = day)) +
  geom_violin(position = position_dodge(width = 0.1), alpha = 0.5, fill = "black") +
  # geom_boxplot(position = position_dodge(width = 5), alpha = 0.5, outlier.shape = NA) +
  facet_grid(parameter ~ group, scales = "free") +
  scale_fill_brewer(type = "qual") +
  # labs(y = "Parameter value") +
  # scale_x_continuous(breaks = c(0, 20, 40, 60, 80, 100)) + 
  theme_bw() +
  labs(y = "Parameter value",
       x = "Days after first hospitalization") +
  guides(alpha = F) +
  theme(legend.title = element_blank()) +
  NULL

```

Converting the cumulative curve to estimate the number of people actively hospitalized yields a maximum estimate of ~100 people actively hospitalized. This estimate is derived from the assumption that an average patient will spend 10 days in the hospital. That assumption appeared to best approximate the state reported data best (Figure 4). However, the state reported data also appear to be staying consistent at around 90 people hospitalized even when model 1 predicts that active hospitalizations should be declining (Figure 4). It is possible that some of the difference is due to underlying differences in hospitalizations in the two subgroups, but active hospitalization data are only available for the state, so we are unable to assess the accuracy of the group-level predictions (Figure 4).  

```{r echo=FALSE, fig.cap="Posterior predictive distributions of active hospitalizations in South Dakota. Lines indicate medians and shading indicates the 50 and 95% prediction intervals", fig.height=10, fig.width=10, message=FALSE, warning=FALSE, paged.print=FALSE}
#active hospitalizations

#model_1
#predictions up to 200 days after the first hospitalization
newdata = tibble(date_num = 0:200)

sd_covid_data <- read.csv(here::here("data/data_kelo.csv")) %>%
  clean_names() %>%
  mutate(date_num = as.numeric(mdy(date)) - 18329,
         date = mdy(date),
         source = "SD_DOH via Keloland news",
         incidence = positive_cases - lag(positive_cases),
         cum_hosp = parse_number(as.character(hospitalized)))

#make predictions of daily hospital needs
predict_dailyhosp <- fitted(fit_weib_state, newdata = newdata, summary = F)  %>%
  as_tibble() %>%
  mutate(iter = 1:nrow(.)) %>%
  filter(iter <= 500) %>% 
  gather(key, value, -iter) %>%
  mutate(date_num = 18328 + parse_number(key),
         date = as_date(date_num)) %>%
  arrange(iter, date_num) %>%
  group_by(iter) %>%
  mutate(inc = as.numeric(value - lag(value, 1))) %>% 
  mutate(daily_total_5 = inc + lag(inc, 1) + lag(inc, 2) + lag(inc, 3) + lag(inc, 4),
         daily_total_10 = inc + lag(inc, 1) + lag(inc, 2) + lag(inc, 3) + lag(inc, 4) + lag(inc, 5) +
            + lag(inc, 6) + lag(inc, 7) + lag(inc, 8) + lag(inc, 9),
         daily_total_12 = inc + lag(inc, 1) + lag(inc, 2) + lag(inc, 3) + lag(inc, 4) + lag(inc, 5) +
            + lag(inc, 6) + lag(inc, 7) + lag(inc, 8) + lag(inc, 9) + lag(inc, 10) + lag(inc, 11),
         daily_total_15 = inc + lag(inc, 1) + lag(inc, 2) + lag(inc, 3) + lag(inc, 4) + lag(inc, 5) +
            + lag(inc, 6) + lag(inc, 7) + lag(inc, 8) + lag(inc, 9) + lag(inc, 10) + lag(inc, 11) + lag(inc, 12) + lag(inc, 13) + lag(inc, 14)) %>% 
  gather(hosp_guess, daily_total, c("daily_total_5":"daily_total_15")) %>% 
  ungroup() %>% 
  mutate(daily_total = rpois(nrow(.), daily_total)) %>%
  replace_na(list(daily_total = 0)) %>%
  group_by(date, hosp_guess) %>% 
  summarize(median = median(daily_total),
            mean = mean(daily_total),
            sd = sd(daily_total),
            high90 = quantile(daily_total, probs = 0.975),
            high50 = quantile(daily_total, probs = 0.75),
            low90 = quantile(daily_total, probs = 0.025),
            low50 = quantile(daily_total, probs = 0.25)) %>% 
  ungroup() %>% 
  mutate(hosp_guess = case_when(hosp_guess == "daily_total_5" ~ "5 days in hospital",
                                hosp_guess == "daily_total_10" ~ "10 days in hospital",
                                hosp_guess == "daily_total_12" ~ "12 days in hospital",
                                TRUE ~ "15 days in hospital"),
         hosp_guess = fct_relevel(hosp_guess, "5 days in hospital"),
         model = "Model 1", 
         group = "South Dakota")


active_plot <- predict_dailyhosp %>% 
ggplot() +
  geom_line(aes(x = date, y = median), color = "dodgerblue") +
  geom_ribbon(aes(x = date, ymin = low90, ymax = high90), fill = 'dodgerblue', alpha = 0.2) +
  geom_ribbon(aes(x = date, ymin = low50, ymax = high50), fill = 'dodgerblue', alpha = 0.2) +
  geom_point(data = sd_covid_data, aes(x = date, y = hospitalized_currently),
             shape = 21, fill = "yellow") +
  # scale_x_date(date_breaks = "months" , date_labels = "%b") +
  theme_classic() +
  facet_grid(.~hosp_guess) +
  # geom_hline(yintercept = all_beds, color = "dodgerblue") +
  # annotate("text", x = as.Date("2020-04-10"), y = 2960, label = "All Hospital Beds\nin SD") +
  labs(y = "Active hospitalizations",
       title = "Predicting active hospitalizations from Weibull model",
       subtitle = "Shading = 50% and 90% prediction intervals") +
  # coord_cartesian(ylim = c(0,100)) +
  NULL




# active_plot - model 2
postgroup_preds <- posterior_samples(fit_weib_group_f) %>% as_tibble() %>% clean_names() %>% 
  mutate(iter = 1:nrow(.),
         ult_rest = b_ult_intercept + b_ult_group_restof_south_dakota,
         omega_rest = b_omega_intercept + b_omega_group_restof_south_dakota,
         theta_rest = b_theta_intercept + b_theta_group_restof_south_dakota) %>% 
  expand_grid(date_num = as.numeric(0:250)) %>% 
  mutate(fit_minn = exp(b_ult_intercept*(1 - exp(-(date_num/b_omega_intercept)^b_theta_intercept))),
         fit_rest = exp(ult_rest*(1 - exp(-(date_num/omega_rest)^theta_rest))),
         fit_state = fit_minn + fit_rest) %>% 
  gather(key, value, c(fit_minn:fit_state)) %>% 
  select(key, iter, value, date_num) %>% 
  mutate(date_num = case_when(grepl("inn", key) ~ date_num + 12, TRUE ~ date_num))


predict_dailyhosp_m2 <- postgroup_preds %>% 
  filter(iter <= 500,
         key != "fit_state") %>% 
  mutate(date = as_date(date_num + 18329)) %>%
  group_by(iter, key) %>% 
  mutate(inc = value - lag(value, 1)) %>% 
  mutate(daily_total_5 = inc + lag(inc, 1) + lag(inc, 2) + lag(inc, 3) + lag(inc, 4),
         daily_total_10 = inc + lag(inc, 1) + lag(inc, 2) + lag(inc, 3) + lag(inc, 4) + lag(inc, 5) +
           + lag(inc, 6) + lag(inc, 7) + lag(inc, 8) + lag(inc, 9),
         daily_total_12 = inc + lag(inc, 1) + lag(inc, 2) + lag(inc, 3) + lag(inc, 4) + lag(inc, 5) +
           + lag(inc, 6) + lag(inc, 7) + lag(inc, 8) + lag(inc, 9) + lag(inc, 10) + lag(inc, 11),
         daily_total_15 = inc + lag(inc, 1) + lag(inc, 2) + lag(inc, 3) + lag(inc, 4) + lag(inc, 5) +
           + lag(inc, 6) + lag(inc, 7) + lag(inc, 8) + lag(inc, 9) + lag(inc, 10) + lag(inc, 11) + lag(inc, 12) + lag(inc, 13) + lag(inc, 14)) %>% 
  gather(hosp_guess, daily_total, c("daily_total_5":"daily_total_15")) %>%
  ungroup() %>% 
  mutate(daily_total = rpois(nrow(.), daily_total))

predhospm2_total <- predict_dailyhosp_m2 %>% ungroup() %>% group_by(date, iter, hosp_guess) %>% 
  summarize(daily_total = sum(daily_total, na.rm = T)) %>% 
  mutate(key = "South Dakota",
         model = "Model 2")

d <- bind_rows(predict_dailyhosp_m2, predhospm2_total)

d2 <- d %>%   
  replace_na(list(daily_total = 0)) %>% 
group_by(date, hosp_guess, key) %>% 
  summarize(median = median(daily_total, na.rm = T),
            mean = mean(daily_total, na.rm = T),
            sd = sd(daily_total, na.rm = T),
            high90 = quantile(daily_total, probs = 0.975, na.rm = T),
            high50 = quantile(daily_total, probs = 0.75, na.rm = T),
            low90 = quantile(daily_total, probs = 0.025, na.rm = T),
            low50 = quantile(daily_total, probs = 0.25, na.rm = T)) %>% 
  ungroup() %>% 
  mutate(hosp_guess = case_when(hosp_guess == "daily_total_5" ~ "5 days in hospital",
                                hosp_guess == "daily_total_10" ~ "10 days in hospital",
                                hosp_guess == "daily_total_12" ~ "12 days in hospital",
                                TRUE ~ "15 days in hospital"),
         hosp_guess = fct_relevel(hosp_guess, "5 days in hospital")) %>% 
  mutate(group = case_when(grepl("minn", key) ~ "Minnehaha County",
                           grepl("rest", key) ~ "Outside of Minnehaha",
                           TRUE ~ "South Dakota"),
         model = "Model 2")


daily_hosp_all <- bind_rows(d2, predict_dailyhosp) %>% 
  mutate(group = fct_relevel(group, "South Dakota", "Minnehaha County"))



raw_active_data <- read_csv(file = "data/data_kelo.csv") %>% clean_names() %>% as_tibble() %>% 
  mutate(date = mdy(date),
         group = "South Dakota",
         Model_1 = hospitalized_currently,
         Model_2 = hospitalized_currently) %>% 
  select(-hospitalized_currently) %>% 
  gather(model, hospitalized_currently, c("Model_1", "Model_2")) %>% 
  mutate(group = fct_relevel(group, "South Dakota", "Minnehaha County"),
         model = case_when(model == "Model_1" ~ "Model 1", TRUE ~ "Model 2"))

#brewer.pal(n = 3, "Accent")

active_daily_group <- daily_hosp_all %>% 
  ggplot(aes(x = date, y= median, fill = group)) + 
  geom_line() +
  geom_ribbon(aes(fill = group, ymin = low90, ymax = high90), alpha = 0.2) +
  geom_ribbon(aes(fill = group, ymin = low50, ymax = high50), alpha = 0.2) +
  facet_grid(hosp_guess ~ model) +
  theme_classic() +
  # scale_color_manual(values = c("grey10", "#7FC97F", "#BEAED4")) +
  scale_fill_manual(values = c("grey10", "#7FC97F", "#BEAED4")) +
  geom_point(data = raw_active_data, aes(x = date, y = hospitalized_currently)) +
  # geom_hline(yintercept = all_beds, color = "dodgerblue") +
  # annotate("text", x = as.Date("2020-04-10"), y = 2960, label = "All Hospital Beds\nin SD") +
  labs(y = "Active hospitalizations",
       x = "") +
  # coord_cartesian(ylim = c(0,500)) +
  theme(legend.title = element_blank()) +
  NULL

active_daily_group
```

# Discussion
The most important result of this study is that modeling trends separately in urban versus rural parts of a state population reveal different projections of cumulative hospitalizations than if modeled only using state-level data. In particular, the model with urban vs. rural groups predicts that Minnehaha County will attain a maximum of ~316 hospitalizations, while areas outside of Minnehaha will attain a maximum of ~785. That results in approximately ~1000 people cumulatively hospitalized. In contrast, the model with only state-level data indicates a 24% smaller number of total people hospitalized (762). 
  In addition to differences in maximum hospitalizations, the models predict different trends of active hospitalizations. Active hospitalizations are more relevant than cumulative hospitalizations for measuring hospital capacity. They have been modeled for the COVID pandemic in a variety of ways with many states adopting a version of an SIR model, such as the CHIME model [@e_weissman_locally_2020]. One challenge with estimating hospitalizations using an SIR-based approach is that they require estimates of a number of transition probabilities to convert infections into hospitalizations. These include estimating the proportion of infected people that become symptomatic, the proportion of those that require hospitalization, the proportion of those that seek hospitalization, the time lag between viral infection as modeled in an SIR, symptom onset, and actual hospitalization [@e_weissman_locally_2020; @imperial_college_covid-19_response_team_estimating_2020]. Early in an epidemic, when hospitalization data are scarce or absent, these models are essential for predicting possible hospitalization scenarios. However, once enough data are available on hospitalizations, it is possible to model the hospitalization curve directly, as we have done here.
  Though we did not attempt to predict COVID-19 infections in South Dakota, it may be possible to use our approach to do so by treating infections as a latent variable that leads to subsequent hospitalizations. @imperial_college_covid-19_response_team_estimating_2020 provide an exmaple of this approach using COVID-19-related deaths rather than hospitalizations. By modeling the dynamics of deaths, they estimated a time-varying reproduction number ($R_t$), which was used to estimate the number of positive cases. Using deaths (or hospitalizations) to estimate infection dynamics may help to overcome limitations in testing capacity, which in turn lead to difficulty in linking publically-reported testing results to true population-level infection rates. This is particularly true in the United States, which has limited testing capacity and no centrally coordinated testing program [@schneider_failing_2020].
  An advantage to the Bayesian approach is that we can use prior values of parameters in a model to fit a model with limited data. In our case, those parameters were conveniently available from New York City. However, if we were modeling a hospitalizaton curve that had no prior estimates, then we might derive priors from another epidemic that had similar disease symptoms(NOT THE RIGHT WORD..) or use prior predictive simulation to bound the model to reasonable prior predictions. The second method is the approach outlined in @gabry_visualization_2019, who demonstrated the importance visualization in choosing prior parameters. In particular, becuase the prior distributions for individual parameters may not be known or are difficult to interpret without consideration of the likelihood [@gelman_prior_2017], it is important to assess the the implications of prior choices using the prior predictive distribution (i.e. simulating potential from the prior distrbutions alone) [@gabry_visualization_2019] (Figure 1). In our model, data simulated from the prior helped to confirm that our model was specified in a way that included a wide range of hospitalization trajectories (Figure 1), but excluded extreme values that might have come from more diffuse priors, such as projecting asymptotes with hospitalizations that are higher than the population of South Dakota.   

# Acknowledgements

# References

# Supplementary Information

Here we compare the prior and posterior distributions of each parameter in the models. Figure S1 indicates how much information was learned about each parameter from adding data. Trace plots indicate well-mixed chains for each model.

```{r echo=FALSE, fig.cap="Comparison of prior and posterior distributions for each parameter in models 1 and 2.", fig.height=4, fig.width=12, message=FALSE, warning=FALSE, paged.print=FALSE}
poststate <- posterior_samples(fit_weib_state) %>% as_tibble() %>% clean_names()
postgroup <- posterior_samples(fit_weib_group_f) %>% as_tibble() %>% clean_names()

poststate_g <- poststate %>% mutate(model = "Model 1", 
                     iter = 1:nrow(.)) %>% 
  select(-lp) %>% 
  gather(key, value, c(-model,-iter)) %>% 
  mutate(prior_post = case_when(grepl("prior", key) ~ "Prior", TRUE ~ "Posterior"),
         key = str_remove(key, "prior_")) %>% 
  separate(key, c("b","param","c"))



postgroup_g <- postgroup %>% mutate(model = "Model 2", 
                     iter = 1:nrow(.)) %>% 
  select(-lp) %>% 
  gather(key, value, c(-model,-iter)) %>% 
  mutate(prior_post = case_when(grepl("prior", key) ~ "Prior", TRUE ~ "Posterior"),
         key = str_remove(key, "prior_")) %>% 
  separate(key, c("b","param","c"), remove = F) %>% 
  mutate(param = case_when(grepl("ult_group", key) ~ "Beta1",
                           grepl("omega_group", key) ~ "Beta2",
                           grepl("theta_group", key) ~ "Beta3",
                           TRUE ~ param))


allpost <- bind_rows(poststate_g, postgroup_g) %>% 
  mutate(prior_post = fct_relevel(prior_post, "Prior"),
         param = case_when(param == "ult" ~ "max",
                           param == "theta" ~ "slope",
                           param == "omega" ~ "inflection",
                           TRUE ~ param),
         param = fct_relevel(param, "max", "slope", "inflection"))

allpost %>% 
  ggplot(aes(x = value, y = ..scaled.., fill = prior_post)) +
  geom_density() +
  facet_grid(model ~ param, scales = "free") +
  scale_fill_brewer() +
  theme_bw() + 
  theme(legend.title = element_blank()) + 
  labs(x = "Parameter Values",
       y = "Density (scaled)") +
  NULL
```


# Trace Plots

*Model 1*
```{r echo=FALSE, fig.cap="Posterior distributions and trace plots for each parameter from Model 1.", fig.height=5, fig.width=8, message=FALSE, warning=FALSE, paged.print=FALSE}

plot(fit_weib_state, N = 10)
```

*Model 2*
```{r echo=FALSE, fig.cap="Posterior distributions and trace plots for each parameter from Model 2.", fig.height=10, fig.width=8, message=FALSE, warning=FALSE, paged.print=FALSE}
plot(fit_weib_group_f, N = 10)
```


# Stan code
Model code in the Stan language is below.

*Model 1*
```{r Model 1, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
stancode(fit_weib_state)
```

*Model 2*
```{r Model 2, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
stancode(fit_weib_group_f)
```


